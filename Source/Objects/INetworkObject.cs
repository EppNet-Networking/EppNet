/////////////////////////////////////////////
/// Filename: INetworkObject.cs
/// Date: February 13, 2025
/// Authors: Maverick Liberty
//////////////////////////////////////////////

using EppNet.Collections;
using EppNet.Commands;
using EppNet.Data;
using EppNet.Logging;
using EppNet.Node;
using EppNet.Utilities;

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace EppNet.Objects
{

    /// <summary>
    /// Base interface for all network objects.<br/>
    /// This is purposely barebones because the required members are<br/>
    /// automatically generated by the source generator. Library users<br/>
    /// aren't expected to implement much other than their own app code.<br/><br/>
    /// 
    /// All network objects implicitly implement <see cref="INetworkObject_Impl"/>
    /// </summary>
    public interface INetworkObject { }

    /// <summary>
    /// "Implementation" of INetworkObject 
    /// </summary>
    public interface INetworkObject_Impl : INodeDescendant, ILoggable
    {
        public ObjectService Service { get; }
        public InternalProperty<EnumObjectState> State { get; }

        /// <summary>
        /// The ID associated with this Network Object
        /// </summary>
        public long ID { get; }

        public InternalProperty<INetworkObject_Impl> Parent { get; }

        public InternalProperty<List<INetworkObject_Impl>> Children { get; }

        public Action<StateChangedEvent> OnStateChanged { get; }
        public Action<ParentChangedEvent> OnParentChanged { get; }
        public Action<ChildAddedEvent> OnChildAdded { get; }
        public Action<ChildRemovedEvent> OnChildRemoved { get; }

    }

    public static class NetworkObjectExtensions
    {

        public static EnumCommandResult ReparentTo<TSelf, TOther>(this TSelf netObj, TOther other)
            where TSelf : class, INetworkObject_Impl
            where TOther : class, INetworkObject_Impl
        {

            // Ensure we're not already parented to the specified parent
            if (netObj.Parent == other)
                return EnumCommandResult.BadArgument;

            // Ensure we can update our parent
            if (netObj.State.Value > EnumObjectState.Generated)
                return EnumCommandResult.InvalidState;

            // Ensure the new parent is capable of receiving a new child
            if (other != null && other.State.Value > EnumObjectState.Generated)
                return EnumCommandResult.InvalidState;

            INetworkObject_Impl curParent = netObj.Parent.Value;
            EnumCommandResult result;

            // Let's remove ourselves from our current parent
            if (curParent != null)
            {
                result = curParent._Internal_RemoveChild(netObj);

                if (!result.IsOk())
                    return result;

                // Everything went okay. Set our parent to null
                netObj.Parent.Set(null);
            }

            // If provided network object isn't null, try to add ourselves to it. If not,
            // set result to Ok.
            result = (other != null) ?
                other._Internal_AddChild(netObj) :
                EnumCommandResult.Ok;

            if (result.IsOk())
            {
                // Everything went okay. Let's set our parent to the provided object.
                netObj.Parent.Set(other);
                netObj.OnParentChanged?.GlobalInvoke(new(netObj, other, curParent, netObj));

                long curParentID = (curParent != null) ? curParent.ID : -1;
                long newParentID = (other != null) ? other.ID : -1;

                netObj.Notify.Debug(new TemplatedMessage("Reparented from Object ID {id} to Object ID {id2}", curParentID, newParentID));
            }

            return result;
        }

        public static EnumCommandResult AddChild<TSelf, TOther>(this TSelf netObj, [NotNull] TOther child)
            where TSelf : class, INetworkObject_Impl
            where TOther : class, INetworkObject_Impl
        {
            EnumCommandResult result = netObj._Internal_AddChild(child);

            if (result.IsOk())
            {
                INetworkObject_Impl curParent = child.Parent.Value;
                child.Parent.Set(netObj);
                child.OnParentChanged?.GlobalInvoke(new(child, netObj, curParent, netObj));
            }

            return result;
        }

        public static EnumCommandResult RemoveChild<TSelf, TOther>(this TSelf netObj, [NotNull] TOther child)
            where TSelf : class, INetworkObject_Impl
            where TOther : class, INetworkObject_Impl
        {
            EnumCommandResult result = netObj._Internal_RemoveChild(child);

            if (result.IsOk())
            {
                INetworkObject_Impl curParent = child.Parent.Value;
                child.Parent.Set(null);
                child.OnParentChanged?.GlobalInvoke(new(child, null, curParent, netObj));
            }

            return result;
        }

        public static bool HasChild<TSelf, TOther>(this TSelf netObj, [NotNull] TOther child)
            where TSelf : class, INetworkObject_Impl
            where TOther : class, INetworkObject_Impl
            => child is not null && netObj.Children.Value.Contains(child);

        public static int ClearChildren<TSelf>(this TSelf netObj)
            where TSelf : class, INetworkObject_Impl
        {
            Iterator<INetworkObject_Impl> iterator = netObj.Children.Value.Iterator();
            int count = 0;

            while (iterator.HasNext())
            {
                INetworkObject_Impl child = iterator.Next();
                EnumCommandResult result = netObj.RemoveChild(child);

                if (result.IsOk())
                    count++;
                else
                    netObj.Notify.Warning(new TemplatedMessage("Failed to remove child Object ID {id}", child.ID));
            }

            return count;
        }

        /// <summary>
        /// Internal system to add a child
        /// </summary>
        /// <typeparam name="TSelf"></typeparam>
        /// <typeparam name="TOther"></typeparam>
        /// <param name="netObj"></param>
        /// <param name="child"></param>
        /// <returns></returns>

        internal static EnumCommandResult _Internal_AddChild<TSelf, TOther>(this TSelf netObj, [NotNull] TOther child)
            where TSelf : class, INetworkObject_Impl
            where TOther : class, INetworkObject_Impl
        {
            // Ensure the child is not null
            if (netObj.IsNotNull(child, message: "Cannot add a null child!"))
                return EnumCommandResult.BadArgument;

            // Ensure this network object has been generated
            if (netObj.State.Value > EnumObjectState.Generated)
                return EnumCommandResult.InvalidState;

            // Ensure the child object has been generated
            if (child.State.Value > EnumObjectState.Generated)
                return EnumCommandResult.InvalidState;

            // Ensure the child doesn't have a parent
            if (child.Parent != null)
                return EnumCommandResult.InvalidState;

            // Let's ensure we don't already have the child
            if (netObj.Children.Value.Contains(child))
                return EnumCommandResult.InvalidState;

            // Add the child now
            netObj.Children.Value.Add(child);
            netObj.OnChildAdded?.GlobalInvoke(new(netObj, child, netObj));

            netObj.Notify.Debug(new TemplatedMessage("Added child Object ID {id}", child.ID));

            return EnumCommandResult.Ok;
        }

        internal static EnumCommandResult _Internal_RemoveChild<TSelf, TOther>(this TSelf netObj, [NotNull] TOther child)
            where TSelf : class, INetworkObject_Impl
            where TOther : class, INetworkObject_Impl
        {
            if (netObj.IsNotNull(child, message: "Cannot remove a null child!"))
                return EnumCommandResult.BadArgument;

            bool removed = netObj.Children.Value.Remove(child);

            if (removed)
            {
                netObj.OnChildRemoved?.GlobalInvoke(new(netObj, child, netObj));
                netObj.Notify.Debug(new TemplatedMessage("Removed child Object ID {id}", child.ID));
            }

            return removed ? EnumCommandResult.Ok : EnumCommandResult.NotFound;
        }

    }

}
