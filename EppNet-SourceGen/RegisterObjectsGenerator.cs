/////////////////////////////////////////////
/// Filename: RegisterObjectsGenerator.cs
/// Date: January 6, 2025
/// Authors: Maverick Liberty
//////////////////////////////////////////////
using EppNet.SourceGen.Models;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using System.Linq;
using System.Text;

using static EppNet.SourceGen.Globals;


namespace EppNet.SourceGen
{

    [Generator]
    public class RegisterObjectsGenerator : IIncrementalGenerator
    {

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {

            // Let's locate our resolvers
            IncrementalValuesProvider<ResolverModel?> resolverProvider = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    NetTypeResolverAttrFullName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: static (ctx, ct) => LocateResolver(ctx.TargetNode, ctx.SemanticModel, ct).Item1
                );

            var resolvers = resolverProvider
                .Where(static r => r is not null)
                .Collect()
                .Select(static (list, _) => list.ToDictionary(r => r.Value.ResolvedTypeFullName, r => r.Value.Name));

            var netObjects = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    NetObjectAttrFullName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: static (ctx, ct) => LocateNetObject(ctx.TargetNode, ctx.SemanticModel, ct)
                )
                //.Combine(resolvers)
                .Where(static o => o.Item1 is not null)
                .Collect()
                .Select(static (list, _) => list.ToDictionary(o => o.Item1.Value.FullyQualifiedName, o => o.Item1));

            var combined = netObjects.Combine(resolvers);

            var netMethods = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    NetMethodAttrFullName,
                    predicate: static (node, _) => node is MethodDeclarationSyntax,
                    transform: static (ctx, ct) => (ctx, ct)
                )
                .Combine(combined)
                .Select(static (pair, _) =>
                {
                    var ((ctx, ct), (netObjects, resolvers)) = pair;
                    return LocateNetMethod(ctx.TargetNode, ctx.SemanticModel, resolvers, netObjects, ct);
                });

            context.RegisterSourceOutput(netObjects, static (spc, objs) =>
            {

                foreach (NetworkObjectModel? obj in objs.Values)
                {
                    if (!obj.HasValue)
                        return;

                    NetworkObjectModel model = obj.Value;
                    StringBuilder builder = new($$"""
                        // <auto-generated/>
                        // full {{model.FullNamespace}}

                        using EppNet.Logging;
                        using EppNet.Node;
                        using EppNet.Objects;
                        using EppNet.Utilities;

                        using System.Diagnostics.CodeAnalysis;

                        namespace {{model.FullNamespace}}
                        {

                            public partial class {{model.Name}} : {{NetworkObjectInternalInterfaceName}}
                            {
                    
                                public ILoggable Notify { get => this; }

                                public NetworkNode Node { get; }
                                public ObjectService Service { get; }
                        
                                public {{model.Name}}([NotNull] ObjectService service)
                                {
                                    Guard.AgainstNull(service);
                                    Node = service.Node;
                                    Service = service;
                                }
                    
                            }

                        }



                        """);

                    string filename = $"{model.Name}.g.cs";
                    spc.AddSource(filename, builder.ToString());
                }

            });

        }


    }


}
