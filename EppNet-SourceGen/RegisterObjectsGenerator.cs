/////////////////////////////////////////////
/// Filename: RegisterObjectsGenerator.cs
/// Date: January 6, 2025
/// Authors: Maverick Liberty
//////////////////////////////////////////////
using EppNet.SourceGen.Models;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using static EppNet.SourceGen.Globals;


namespace EppNet.SourceGen
{

    [Generator]
    public class RegisterObjectsGenerator : IIncrementalGenerator
    {

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {

            ConcurrentDictionary<string, string> resolverDict = new();

            // Let's locate our resolvers
            var resolvers = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    NetTypeResolverAttrFullName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: static (ctx, ct) => TryCreateResolver(ctx.TargetNode as CSharpSyntaxNode, ctx.SemanticModel, ct).Item1
                )
                .Where(static r => r is not null)
                .Collect()
                .Select(static (list, _) => list.ToDictionary(r => r!.Value.ResolvedTypeFullName, r => r!.Value.Name));

            var netObjects = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    NetObjectAttrFullName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: (ctx, ct) => TryCreateNetObject(ctx.TargetNode as CSharpSyntaxNode, ctx.SemanticModel, null, ct)
                )
                .Where(static o => o.Item1 is not null)
                .Collect()
                .Select(static (list, _) => list.ToDictionary(o => o!.Item1.Value.FullyQualifiedName, o => o!.Item1.Value));

            context.RegisterSourceOutput(netObjects.Combine(resolvers), static (SourceProductionContext spc, (Dictionary<string, NetworkObjectModel>, Dictionary<string, string>) b) =>
            {

                (Dictionary<string, NetworkObjectModel> objs, Dictionary<string, string> resolverDict) = b;

                foreach (KeyValuePair<string, NetworkObjectModel> kvp in objs)
                {
                    string fqn = kvp.Key;
                    NetworkObjectModel model = kvp.Value;

                    StringBuilder availableMethods = new();

                    foreach (KeyValuePair<string, EquatableList<NetworkMethodModel>> kvp2 in model.Methods)
                    {
                        EquatableList<NetworkMethodModel> methods = kvp2.Value;

                        foreach (NetworkMethodModel method in methods)
                            availableMethods.AppendLine($"// - {method.ToString()}");
                    }

                    if (availableMethods.Length == 0)
                        availableMethods.Append($"// no methods found?!?! HELLO!? Methods.Count: {model.Methods.Count}");

                    StringBuilder hierarchy = new();

                    if (model.NetObjectHierarchy == null)
                        hierarchy.AppendLine("// - System.Object");
                    else
                    {
                        foreach (string bFQN in model.NetObjectHierarchy)
                            hierarchy.AppendLine($"// - {bFQN}");
                    }

                    StringBuilder builder = new($$"""
                        // <auto-generated/>
                        // full {{model.FullNamespace}}
                        // hierarchy:
                        {{hierarchy.ToString()}}
                        // available methods:
                        {{availableMethods.ToString()}}
                        // dist: {{model.Distribution}}

                        using EppNet.Logging;
                        using EppNet.Node;
                        using EppNet.Objects;
                        using EppNet.Utilities;

                        using System.Diagnostics.CodeAnalysis;

                        namespace {{model.FullNamespace}}
                        {

                            public partial class {{model.Name}} : {{NetworkObjectInternalInterfaceName}}
                            {
                    
                                public ILoggable Notify { get => this; }

                                public NetworkNode Node { get; }
                                public ObjectService Service { get; }
                        
                                public {{model.Name}}([NotNull] ObjectService service)
                                {
                                    Guard.AgainstNull(service);
                                    Node = service.Node;
                                    Service = service;
                                }
                    
                            }

                        }



                        """);

                    string filename = $"{model.Name}.g.cs";
                    spc.AddSource(filename, builder.ToString());
                }

            });

        }


    }


}
