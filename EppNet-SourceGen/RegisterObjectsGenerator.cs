/////////////////////////////////////////////
/// Filename: RegisterObjectsGenerator.cs
/// Date: January 6, 2025
/// Authors: Maverick Liberty
//////////////////////////////////////////////
using EppNet.SourceGen.Models;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using System.Linq;
using System.Text;

using static EppNet.SourceGen.Globals;


namespace EppNet.SourceGen
{

    [Generator]
    public class RegisterObjectsGenerator : IIncrementalGenerator
    {

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {

            // Let's locate our resolvers
            IncrementalValuesProvider<ResolverModel?> resolverProvider = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    NetTypeResolverAttrFullName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: static (ctx, ct) => LocateResolver(ctx.TargetNode, ctx.SemanticModel, ct).Item1
                );

            IncrementalValuesProvider<NetworkObjectModel?> netObjProvider = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    NetObjectAttrFullName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: static (ctx, ct) => LocateNetObject(ctx.TargetNode, ctx.SemanticModel, ct).Item1
                );

            //resolverProvider.Select((model, token) => model.HasValue && )

            context.RegisterSourceOutput(netObjProvider, static (spc, obj) =>
            {

                if (!obj.HasValue)
                    return;

                NetworkObjectModel model = obj.Value;
                StringBuilder builder = new($$"""
                    // <auto-generated/>
                    // full {{model.FullNamespace}}

                    using EppNet.Logging;
                    using EppNet.Node;
                    using EppNet.Objects;
                    using EppNet.Utilities;

                    using System.Diagnostics.CodeAnalysis;

                    namespace {{model.FullNamespace}}
                    {

                        public partial class {{model.Name}} : ILoggable, INodeDescendant
                        {
                    
                            public ILoggable Notify { get => this; }

                            public NetworkNode Node { get; }
                            public ObjectService Service { get; }
                        
                            public {{model.Name}}([NotNull] ObjectService service)
                            {
                                Guard.AgainstNull(service);
                                Node = service.Node;
                                Service = service;
                            }
                    
                        }

                    }



                    """);

                string filename = $"{model.Name}.g.cs";
                spc.AddSource(filename, builder.ToString());
            });

        }


    }


}
